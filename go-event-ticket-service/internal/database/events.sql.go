// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: events.sql

package database

import (
	"context"
	"database/sql"
)

const count = `-- name: Count :one
select count(*) from events
`

func (q *Queries) Count(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, count)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEvents = `-- name: CreateEvents :execresult
insert into
	events (
		id,
		title,
		address,
		image_url,
		organizer_id,
		event_category_id,
		creator_id,
		modifier_id,
		deletor_id,
		created_at,
		modified_at,
		deleted_at
	)
values
	(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?)
`

type CreateEventsParams struct {
	ID              string
	Title           string
	Address         string
	ImageUrl        sql.NullString
	OrganizerID     string
	EventCategoryID string
	CreatorID       string
	ModifierID      string
	DeletorID       string
	CreatedAt       int64
	ModifiedAt      int64
	DeletedAt       int64
}

func (q *Queries) CreateEvents(ctx context.Context, arg CreateEventsParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createEvents,
		arg.ID,
		arg.Title,
		arg.Address,
		arg.ImageUrl,
		arg.OrganizerID,
		arg.EventCategoryID,
		arg.CreatorID,
		arg.ModifierID,
		arg.DeletorID,
		arg.CreatedAt,
		arg.ModifiedAt,
		arg.DeletedAt,
	)
}

const getDeletedEvents = `-- name: GetDeletedEvents :many
select
	e.id,
	e.title,
	e.address,
	e.image_url,
	e.organizer_id,
	e.event_category_id,
	e.creator_id,
	e.modifier_id,
	e.deletor_id,
	e.created_at,
	e.modified_at,
	e.deleted_at,
	ec.title as event_category_title,
	ec.description as event_category_description
from
	events e
	join event_categories ec on e.event_category_id = ec.id
where
	e.deleted_at != 0
order by
	e.created_at desc
limit
	?
offset
	?
`

type GetDeletedEventsParams struct {
	Limit  int32
	Offset int32
}

type GetDeletedEventsRow struct {
	ID                       string
	Title                    string
	Address                  string
	ImageUrl                 sql.NullString
	OrganizerID              string
	EventCategoryID          string
	CreatorID                string
	ModifierID               string
	DeletorID                string
	CreatedAt                int64
	ModifiedAt               int64
	DeletedAt                int64
	EventCategoryTitle       string
	EventCategoryDescription sql.NullString
}

func (q *Queries) GetDeletedEvents(ctx context.Context, arg GetDeletedEventsParams) ([]GetDeletedEventsRow, error) {
	rows, err := q.db.QueryContext(ctx, getDeletedEvents, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDeletedEventsRow
	for rows.Next() {
		var i GetDeletedEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Address,
			&i.ImageUrl,
			&i.OrganizerID,
			&i.EventCategoryID,
			&i.CreatorID,
			&i.ModifierID,
			&i.DeletorID,
			&i.CreatedAt,
			&i.ModifiedAt,
			&i.DeletedAt,
			&i.EventCategoryTitle,
			&i.EventCategoryDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventById = `-- name: GetEventById :one
select
	e.id,
	e.title,
	e.address,
	e.image_url,
	e.organizer_id,
	e.event_category_id,
	e.creator_id,
	e.modifier_id,
	e.deletor_id,
	e.created_at,
	e.modified_at,
	e.deleted_at,
	ec.title as event_category_title,
	ec.description as event_category_description
from
	events e
	join event_categories ec on e.event_category_id = ec.id
where
	e.deleted_at = 0
	and e.id = ?
limit
	1
`

type GetEventByIdRow struct {
	ID                       string
	Title                    string
	Address                  string
	ImageUrl                 sql.NullString
	OrganizerID              string
	EventCategoryID          string
	CreatorID                string
	ModifierID               string
	DeletorID                string
	CreatedAt                int64
	ModifiedAt               int64
	DeletedAt                int64
	EventCategoryTitle       string
	EventCategoryDescription sql.NullString
}

func (q *Queries) GetEventById(ctx context.Context, id string) (GetEventByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getEventById, id)
	var i GetEventByIdRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Address,
		&i.ImageUrl,
		&i.OrganizerID,
		&i.EventCategoryID,
		&i.CreatorID,
		&i.ModifierID,
		&i.DeletorID,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.DeletedAt,
		&i.EventCategoryTitle,
		&i.EventCategoryDescription,
	)
	return i, err
}

const getEvents = `-- name: GetEvents :many
select
	e.id,
	e.title,
	e.address,

	e.image_url,
	e.organizer_id,
	e.event_category_id,
	e.creator_id,
	e.modifier_id,
	e.deletor_id,
	e.created_at,
	e.modified_at,
	e.deleted_at,
	ec.title as event_category_title,
	ec.description as event_category_description
from
	events e
	join event_categories ec on e.event_category_id = ec.id
where
	e.deleted_at = 0
order by
	e.created_at desc
limit
	?
offset
	?
`

type GetEventsParams struct {
	Limit  int32
	Offset int32
}

type GetEventsRow struct {
	ID                       string
	Title                    string
	Address                  string
	ImageUrl                 sql.NullString
	OrganizerID              string
	EventCategoryID          string
	CreatorID                string
	ModifierID               string
	DeletorID                string
	CreatedAt                int64
	ModifiedAt               int64
	DeletedAt                int64
	EventCategoryTitle       string
	EventCategoryDescription sql.NullString
}

func (q *Queries) GetEvents(ctx context.Context, arg GetEventsParams) ([]GetEventsRow, error) {
	rows, err := q.db.QueryContext(ctx, getEvents, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventsRow
	for rows.Next() {
		var i GetEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Address,
			&i.ImageUrl,
			&i.OrganizerID,
			&i.EventCategoryID,
			&i.CreatorID,
			&i.ModifierID,
			&i.DeletorID,
			&i.CreatedAt,
			&i.ModifiedAt,
			&i.DeletedAt,
			&i.EventCategoryTitle,
			&i.EventCategoryDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsByCategoryId = `-- name: GetEventsByCategoryId :many
select
	e.id,
	e.title,
	e.address,
	e.image_url,
	e.organizer_id,
	e.event_category_id,
	e.creator_id,
	e.modifier_id,
	e.deletor_id,
	e.created_at,
	e.modified_at,
	e.deleted_at,
	ec.title as event_category_title,
	ec.description as event_category_description
from
	events e
	join event_categories ec on e.event_category_id = ec.id
where
	e.deleted_at = 0
	and e.event_category_id = ?
limit
	?
offset
	?
`

type GetEventsByCategoryIdParams struct {
	EventCategoryID string
	Limit           int32
	Offset          int32
}

type GetEventsByCategoryIdRow struct {
	ID                       string
	Title                    string
	Address                  string
	ImageUrl                 sql.NullString
	OrganizerID              string
	EventCategoryID          string
	CreatorID                string
	ModifierID               string
	DeletorID                string
	CreatedAt                int64
	ModifiedAt               int64
	DeletedAt                int64
	EventCategoryTitle       string
	EventCategoryDescription sql.NullString
}

func (q *Queries) GetEventsByCategoryId(ctx context.Context, arg GetEventsByCategoryIdParams) ([]GetEventsByCategoryIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getEventsByCategoryId, arg.EventCategoryID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventsByCategoryIdRow
	for rows.Next() {
		var i GetEventsByCategoryIdRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Address,
			&i.ImageUrl,
			&i.OrganizerID,
			&i.EventCategoryID,
			&i.CreatorID,
			&i.ModifierID,
			&i.DeletorID,
			&i.CreatedAt,
			&i.ModifiedAt,
			&i.DeletedAt,
			&i.EventCategoryTitle,
			&i.EventCategoryDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsByOrganizerId = `-- name: GetEventsByOrganizerId :many
select
	e.id,
	e.title,
	e.address,
	e.image_url,
	e.organizer_id,
	e.event_category_id,
	e.creator_id,
	e.modifier_id,
	e.deletor_id,
	e.created_at,
	e.modified_at,
	e.deleted_at,
	ec.title as event_category_title,
	ec.description as event_category_description
from
	events e
	join event_categories ec on e.event_category_id = ec.id
where
	e.deleted_at = 0
	and e.organizer_id = ?
order by
	e.created_at desc
limit
	?
offset
	?
`

type GetEventsByOrganizerIdParams struct {
	OrganizerID string
	Limit       int32
	Offset      int32
}

type GetEventsByOrganizerIdRow struct {
	ID                       string
	Title                    string
	Address                  string
	ImageUrl                 sql.NullString
	OrganizerID              string
	EventCategoryID          string
	CreatorID                string
	ModifierID               string
	DeletorID                string
	CreatedAt                int64
	ModifiedAt               int64
	DeletedAt                int64
	EventCategoryTitle       string
	EventCategoryDescription sql.NullString
}

func (q *Queries) GetEventsByOrganizerId(ctx context.Context, arg GetEventsByOrganizerIdParams) ([]GetEventsByOrganizerIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getEventsByOrganizerId, arg.OrganizerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventsByOrganizerIdRow
	for rows.Next() {
		var i GetEventsByOrganizerIdRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Address,
			&i.ImageUrl,
			&i.OrganizerID,
			&i.EventCategoryID,
			&i.CreatorID,
			&i.ModifierID,
			&i.DeletorID,
			&i.CreatedAt,
			&i.ModifiedAt,
			&i.DeletedAt,
			&i.EventCategoryTitle,
			&i.EventCategoryDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreEvent = `-- name: RestoreEvent :exec
update events
set
	deleted_at = 0,
	deletor_id = ''
where
	id = ?
`

func (q *Queries) RestoreEvent(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, restoreEvent, id)
	return err
}

const softDeleteEvent = `-- name: SoftDeleteEvent :exec
update events
set
	deleted_at = ?,
	deletor_id = ?
where
	id = ?
`

type SoftDeleteEventParams struct {
	DeletedAt int64
	DeletorID string
	ID        string
}

func (q *Queries) SoftDeleteEvent(ctx context.Context, arg SoftDeleteEventParams) error {
	_, err := q.db.ExecContext(ctx, softDeleteEvent, arg.DeletedAt, arg.DeletorID, arg.ID)
	return err
}

const updateEvents = `-- name: UpdateEvents :exec
UPDATE events
SET
	title = COALESCE(?, title),
	address = COALESCE(?, address),
	image_url = COALESCE(?, image_url),
	organizer_id = COALESCE(?, organizer_id),
	modified_at = COALESCE(?, modified_at),
	modifier_id = COALESCE(?, modifier_id)
WHERE
	id = ?
	AND deleted_at = 0
`

type UpdateEventsParams struct {
	Title       sql.NullString
	Address     sql.NullString
	ImageUrl    sql.NullString
	OrganizerID sql.NullString
	ModifiedAt  int64
	ModifierID  string
	ID          string
}

func (q *Queries) UpdateEvents(ctx context.Context, arg UpdateEventsParams) error {
	_, err := q.db.ExecContext(ctx, updateEvents,
		arg.Title,
		arg.Address,
		arg.ImageUrl,
		arg.OrganizerID,
		arg.ModifiedAt,
		arg.ModifierID,
		arg.ID,
	)
	return err
}
